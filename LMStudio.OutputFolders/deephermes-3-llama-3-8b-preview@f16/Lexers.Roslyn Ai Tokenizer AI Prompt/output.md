Given the detailed requirements and coding standards specified, I'll outline a comprehensive C# solution structure for creating an AST (Abstract Syntax Tree) generator using the Roslyn compiler. This solution will include unit tests for lexing the Abstract Syntax Tree.

### Directory Structure
```
ASTGenerator/
│
├── ASTGenerator.sln                 # Solution file
│
├── Core/
│   ├── Program.cs                   # Main entry point
│   └── ...
│
├── Models/
│   ├── Node.cs                      # Base class for AST nodes
│   ├── ExpressionNode.cs            # Specific expression node type
│   ├── StatementNode.cs             # Specific statement node type
│   └── ...
│
├── Services/
│   ├── ASTBuilder.cs                # Builds the AST from C# source code
│   ├── PrettyPrinter.cs             # Prints the AST in a readable format
│   └── ReflowGenerator.cs           # Generates valid C# code from AST
│
└── Tests/
    ├── LexingTests.cs               # Unit tests for lexing the AST
    └── ...
```

### Key Components

#### Models/Node.cs
```csharp
public abstract class Node
{
    public int Line { get; set; }
    public int Column { get; set; }

    // Common methods and properties for all AST nodes
}
```

#### Services/ASTBuilder.cs
This service will use Roslyn to parse C# source code into an AST. It will be responsible for traversing the syntax tree, identifying different types of nodes (expressions, statements), and instantiating corresponding classes from `Models`.

#### Services/PrettyPrinter.cs
The Pretty Printer will take the AST generated by the `ASTBuilder` and output it in a human-readable format. This includes methods to recursively traverse the tree and print each node's type and value.

#### Services/ReflowGenerator.cs
This service converts the AST back into valid C# code. It involves traversing the syntax tree, generating corresponding code constructs, and ensuring proper formatting according to C# standards.

#### Tests/LexingTests.cs
Unit tests for verifying that the lexing process correctly identifies and categorizes elements of a given C# source code file.

### Code Example: ASTBuilder

```csharp
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using System.IO;
using System.Linq;

public class ASTBuilder
{
    public Node BuildAST(string sourceCode)
    {
        var tree = CSharpSyntaxTree.ParseText(sourceCode);
        var compilation = CSharpCompilation.Create("MyCompilation")
            .AddReferences(MetadataFile: "netstandard.library.dll", 
                           Assembly: "netstandard")
            .AddSyntaxTrees(tree);

        var semanticModel = compilation.GetSemanticModel(tree);

        // This is a simplified example. In practice, you'd need to traverse
        // the syntax tree to identify different types of nodes and instantiate
        // corresponding classes from Models.
        
        // Example: Extracting declaration statements
        foreach (var statement in tree.GetRoot().DescendantNodes().OfType<StatementSyntax>())
        {
            var nodeType = semanticModel.GetDeclaredSymbol(statement);
            // Instantiate a specific subclass of Node based on the node type
        }

        return new Node(); // Simplified; replace with actual AST node instantiation.
    }
}
```

### Unit Testing: LexingTests.cs

```csharp
using Microsoft.CodeAnalysis.CSharp;
using Xunit;

public class LexingTests
{
    [Fact]
    public void TestSimpleExpressionLexing()
    {
        var sourceCode = "var x = 5;"; // Simple C# code snippet
        
        var syntaxTree = CSharpSyntaxTree.ParseText(sourceCode);
        
        // Use PrettyPrinter to display the AST
        var printer = new Services.PrettyPrinter();
        string astOutput = printer.PrintAst(syntaxTree);
        
        Assert.Contains("VariableDeclarator", astOutput);
    }
}
```

This outline and code snippets provide a starting point for implementing an AST generator with Roslyn, adhering to the specified requirements and coding standards. The solution will include detailed unit tests covering various aspects of the AST generation process, ensuring robustness and reliability.